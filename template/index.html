<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的Rust HTTP服务器报告</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
        }
        h1 {
            color: #333;
        }
        h2 {
            color: #666;
            margin-top: 20px;
        }
        p {
            color: #555;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>我的Rust HTTP服务器学习报告</h1>
    <h2>一、学习背景与目标</h2>
    <p>作为Rust语言的初学者，我希望通过构建一个HTTP服务器来深入理解Rust的核心概念，如所有权、生命周期、类型系统，以及网络编程和文件操作等相关知识。目标是创建一个能够处理基本HTTP请求、响应并具备一定灵活性的服务器。</p>
    <h2>二、功能实现</h2>
    <h3>1. 请求处理</h3>
    <p>服务器能够解析HTTP请求，提取请求方法（如GET、POST等）、路径、版本、头部信息以及请求体。通过自定义的`parse_http_request`函数实现，该函数利用`BufReader`逐行读取请求数据，并根据HTTP协议格式进行解析。例如：</p>
    <pre>
fn parse_http_request(stream: &TcpStream) -> Result<HttpRequest, ()> {
    let lines = BufReader::new(stream)
      .lines()
      .map(|line| line.unwrap())
      .take_while(|line|!line.is_empty())
      .collect::<Vec<String>>();
    // 解析请求行
    let request_line = lines[0].split_whitespace().collect::<Vec<&str>>();
    if request_line.len() != 3 {
        return Err(());
    }
    let method = request_line[0].to_string();
    let path = request_line[1].to_string();
    let version = request_line[2].to_string();
    // 解析头部信息
    let mut headers = std::collections::HashMap::new();
    let mut i = 1;
    while i < lines.len() &&!lines[i].is_empty() {
        let parts: Vec<&str> = lines[i].splitn(2, ": ").collect();
        if parts.len() == 2 {
            headers.insert(parts[0].to_string(), parts[1].to_string());
        }
        i += 1;
    }
    // 解析请求体
    let body = if i + 1 < lines.len() {
        Some(lines[i + 1..].join("\r\n"))
    } else {
        None
    };
    let remote_addr = stream.peer_addr();
    if let Err(_) = remote_addr {
        return Err(());
    }
    Ok(HttpRequest {
        remote_addr: remote_addr.unwrap().to_string(),
        method: HttpMethod::name_of(method.to_uppercase()).unwrap(),
        path,
        version,
        headers,
        body,
    })
}
    </pre>
    <h3>2. 响应生成</h3>
    <p>根据请求处理结果，服务器可以生成不同类型的响应。支持返回文本、JSON数据以及视图文件（HTML）。`HttpResponse`结构体用于封装响应信息，通过不同的方法来设置状态码、头部信息、响应体或视图。例如：</p>
    <pre>
impl HttpResponse {
    fn view(view_name: String) -> HttpResponse {
        HttpResponse {
            status_code: 200,
            headers: Some(HashMap::from([(
                "Content-Type".to_string(),
                "text/html".to_string(),
            )])),
            body: None,
            view: Some(view_name.into()),
        }
    }
    fn json(json: String) -> HttpResponse {
        HttpResponse {
            status_code: 200,
            headers: Some(HashMap::from([(
                "Content-Type".to_string(),
                "application/json".to_string(),
            )])),
            body: Some(json),
            view: None,
        }
    }
    fn new(status_code: u16) -> HttpResponse {
        HttpResponse {
            status_code,
            headers: None,
            body: None,
            view: None,
        }
    }
    // 其他设置方法...
}
    </pre>
    <h3>3. 中间件支持</h3>
    <p>服务器具备中间件功能，通过`Middleware`结构体和`MiddlewareChain`来实现。中间件可以在请求处理前后执行一些通用逻辑，如日志记录。例如，添加一个日志中间件：</p>
    <pre>
http_server.add_middleware(Middleware::new(|chain, ctx| {
    println!(
        "from {} {:?} {}",
        ctx.request.remote_addr, ctx.request.method, ctx.request.path
    );
}));
    </pre>
    <h2>三、遇到的问题与解决方法</h2>
    <h3>1. 所有权与生命周期问题</h3>
    <p>在处理`Option`类型数据和路径操作时，经常遇到所有权转移和生命周期不匹配的错误。例如，在拼接视图路径时，从`Option<String>`中获取值会导致所有权移动错误。通过使用`as_ref`方法获取引用，以及合理使用`let`绑定延长临时值的生命周期来解决。</p>
    <h3>2. 错误处理</h3>
    <p>在请求解析和文件读取等操作中，需要处理各种可能的错误。最初，错误处理不够完善，导致程序在遇到错误时崩溃。后来使用`Result`类型和`?`运算符来简化错误处理流程，使代码更加健壮。</p>
    <h2>四、总结与展望</h2>
    <p>通过这次实践，我对Rust语言有了更深入的理解和掌握。学会了如何运用Rust的特性进行网络编程、文件操作和构建模块化的代码结构。未来，我计划进一步完善服务器功能，如支持更多的HTTP方法、优化性能、添加安全机制等，同时继续学习Rust的高级特性，提升编程能力。</p>
</body>
</html>